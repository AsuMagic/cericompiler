#include "codegen.hpp"

#include "types.hpp"
#include "util/enums.hpp"
#include "variable.hpp"

#include <fmt/core.h>
#include <ostream>

void CodeGen::begin_program() { m_output << "# This code was generated by ceri-compiler\n"; }
void CodeGen::finalize_program() {}

void CodeGen::begin_executable_section() { m_output << ".text\n"; }
void CodeGen::finalize_executable_section() {}

void CodeGen::begin_main_procedure()
{
	m_output << ".globl main\n"
				"main:\n"
				"\tmovq %rsp, %rbp # Save the position of the top of the stack\n";
}

void CodeGen::finalize_main_procedure()
{
	m_output << "\tmovq %rbp, %rsp # Restore the position of the top of the stack\n"
				"\tret\n";
}

void CodeGen::begin_global_data_section()
{
	m_output << ".data\n"
				".align 8\n"
				"__cc_format_string_llu: .string \"%llu\\n\"\n"
				"__cc_format_string_c:   .string \"%c\" # No newline; this is intended\n"
				"__cc_format_string_f:   .string \"%f\\n\"\n";
}

void CodeGen::finalize_global_data_section() {}

void CodeGen::define_global_variable(const Variable& variable)
{
	m_output << fmt::format("{}:\n\t", variable.mangled_name());

	// NOTE: non 64-bit loads are still loaded with 64-bit pushes.
	//       Realistically, this does not matter, though.
	//       This might be problematic when dealing with a C FFI for example however, since we (probably) need to clear
	//       up the upper bits of the registers when we pass small data types.

	switch (variable.type.type)
	{
	case Type::BOOLEAN:
	case Type::CHAR: m_output << ".byte 0"; break;
	case Type::UNSIGNED_INT: m_output << ".quad 0"; break;
	case Type::DOUBLE: m_output << ".double 0.0"; break;
	default: throw UnimplementedError{"Unimplemented global variable type"};
	}

	m_output << fmt::format(" # type: {}\n", type_name(variable.type.type).str());
}

void CodeGen::load_variable(const Variable& variable)
{
	m_output << fmt::format("\tpush {}\n", variable.mangled_name());
}
void CodeGen::load_i64(uint64_t value)
{
	if ((value >> 32) != 0)
	{
		// The value does not fit into an imm32, so we cannot use push directly.
		m_output << fmt::format(
			"\tmovq $0x{:016x}, %rax\n"
			"\tpush %rax\n",
			value);
	}
	else
	{
		m_output << fmt::format("\tpush $0x{:016x}\n", value);
	}
}

void CodeGen::store_variable(const Variable& variable)
{
	m_output << fmt::format("\tpop {}\n", variable.mangled_name());
}

void CodeGen::alu_and_bool()
{
	alu_load_binop(Type::BOOLEAN);

	m_output << "\tandq %rax, %rbx\n"
				"\tpush %rax\n";
}

void CodeGen::alu_or_bool()
{
	alu_load_binop(Type::BOOLEAN);

	m_output << "\torq %rbx, %rax\n"
				"\tpush %rax\n";
}

void CodeGen::alu_not_bool() { m_output << "\tnotq (%rsp)\n"; }

void CodeGen::alu_add(Type type)
{
	alu_load_binop(type);

	switch (type)
	{
	case Type::UNSIGNED_INT:
	{
		m_output << "\taddq %rbx, %rax\n"
					"\tpush %rax\n";
		break;
	}

	case Type::DOUBLE:
	{
		m_output << "\tfaddp %st(0), %st(1)\n";
		alu_store_f64();
		break;
	}

	default:
	{
		throw UnimplementedTypeSupportError{};
	}
	}
}

void CodeGen::alu_sub(Type type)
{
	alu_load_binop(type);

	switch (type)
	{
	case Type::UNSIGNED_INT:
	{
		m_output << "\tsubq %rbx, %rax\n"
					"\tpush %rax\n";
		break;
	}

	case Type::DOUBLE:
	{
		m_output << "\tfsubp %st(0), %st(1)\n";
		alu_store_f64();
		break;
	}

	default:
	{
		throw UnimplementedTypeSupportError{};
	}
	}
}

void CodeGen::alu_multiply(Type type)
{
	alu_load_binop(type);

	switch (type)
	{
	case Type::UNSIGNED_INT:
	{
		m_output << "\tmulq %rbx\n"
					"\tpush %rax\n";
		break;
	}

	case Type::DOUBLE:
	{
		m_output << "\tfmulp %st(0), %st(1)\n";
		alu_store_f64();
		break;
	}

	default:
	{
		throw UnimplementedTypeSupportError{};
	}
	}
}

void CodeGen::alu_divide(Type type)
{
	alu_load_binop(type);

	switch (type)
	{
	case Type::UNSIGNED_INT:
	{
		m_output << "\tmovq $0, %rdx # Higher part of numerator\n"
					"\tdiv %rbx # Quotient goes to %rax\n"
					"\tpush %rax\n";
		break;
	}

	case Type::DOUBLE:
	{
		m_output << "\tfdivp %st(0), %st(1)\n";
		alu_store_f64();
		break;
	}

	default:
	{
		throw UnimplementedTypeSupportError{};
	}
	}
}

void CodeGen::alu_modulus(Type type)
{
	switch (type)
	{
	case Type::UNSIGNED_INT:
	{
		alu_load_binop(type);
		m_output << "\tmovq $0, %rdx # Higher part of numerator\n"
					"\tdiv %rbx # Remainder goes to %rdx\n"
					"\tpush %rax\n";
		break;
	}

	case Type::DOUBLE:
	{
		// no alu_load_binop here: we load to xmm0/1
		// use standard C fmod
		m_output << "\tmovsd 8(%rsp), %xmm0\n"
					"\tmovsd (%rsp), %xmm1\n"
					"\taddq $8, %rsp\n"
					"\tcall fmod\n"
					"\tmovsd %xmm0, (%rsp)\n";
		break;
	}

	default:
	{
		throw UnimplementedTypeSupportError{};
	}
	}
}

void CodeGen::alu_equal(Type type) { alu_compare(type, "je"); }
void CodeGen::alu_not_equal(Type type) { alu_compare(type, "jne"); }
void CodeGen::alu_greater_equal(Type type) { alu_compare(type, "jae"); }
void CodeGen::alu_lower_equal(Type type) { alu_compare(type, "jbe"); }
void CodeGen::alu_greater(Type type) { alu_compare(type, "ja"); }
void CodeGen::alu_lower(Type type) { alu_compare(type, "jb"); }

void CodeGen::convert(Type source, Type destination)
{
	if (source == destination)
	{
		// no-op
		return;
	}

	if (check_enum_range(source, Type::FIRST_INTEGRAL, Type::LAST_INTEGRAL) || destination == Type::CHAR)
	{
		if (check_enum_range(destination, Type::FIRST_INTEGRAL, Type::LAST_INTEGRAL) || destination == Type::CHAR)
		{
			// no-op possible. those are 64-bit values regardless
			return;
		}

		if (destination == Type::DOUBLE)
		{
			m_output << "\tfildq (%rsp)\n"
						"\tfstpl (%rsp)\n";

			return;
		}
	}

	if (check_enum_range(source, Type::FIRST_FLOATING, Type::LAST_FLOATING))
	{
		if (check_enum_range(destination, Type::FIRST_INTEGRAL, Type::LAST_INTEGRAL) || destination == Type::CHAR)
		{
			m_output << "\tfldl (%rsp)\n"
						"\tfistpq (%rsp)\n";

			return;
		}
	}

	throw UnimplementedTypeSupportError{fmt::format(
		"unsupported type conversion occured: {} -> {}", type_name(source).str(), type_name(destination).str())};
}

IfStatement CodeGen::statement_if_prepare() { return {++m_label_tag}; }

void CodeGen::statement_if_post_check(IfStatement statement)
{
	m_output << fmt::format(
		"\tpopq %rax\n"
		"\ttest %rax, %rax\n"
		"\tjz __false{tag}\n"
		"__true{tag}:\n",
		fmt::arg("tag", statement.saved_tag));
}

void CodeGen::statement_if_with_else(IfStatement statement)
{
	m_output << fmt::format(
		"\tjmp __next{tag}\n"
		"__false{tag}:\n",
		fmt::arg("tag", statement.saved_tag));
}

void CodeGen::statement_if_without_else(IfStatement statement)
{
	m_output << fmt::format("__false{}:\n", statement.saved_tag);
}

void CodeGen::statement_if_finalize(IfStatement statement)
{
	m_output << fmt::format("__next{}:\n", statement.saved_tag);
}

WhileStatement CodeGen::statement_while_prepare()
{
	WhileStatement statement{++m_label_tag};
	m_output << fmt::format("__while{}:\n", statement.saved_tag);

	return statement;
}

void CodeGen::statement_while_post_check(WhileStatement statement)
{
	m_output << fmt::format(
		"\tpop %rax\n"
		"\ttest %rax, %rax\n"
		"\tjz __next{tag}\n",
		fmt::arg("tag", statement.saved_tag));
}

void CodeGen::statement_while_finalize(WhileStatement statement)
{
	m_output << fmt::format(
		"\tjmp __while{tag}\n"
		"__next{tag}:\n",
		fmt::arg("tag", statement.saved_tag));
}

ForStatement CodeGen::statement_for_prepare(const Variable& assignement_variable)
{
	return {++m_label_tag, &assignement_variable};
}

void CodeGen::statement_for_post_assignment(ForStatement statement)
{
	m_output << fmt::format("__for{}:\n", statement.saved_tag);
}

void CodeGen::statement_for_post_check(ForStatement statement)
{
	// we branch *out* if var < %rax, mind the op order in at&t
	m_output << fmt::format(
		"\tpop %rax\n"
		"\tcmpq {name}, %rax\n"
		"\tjl __next{tag}\n",
		fmt::arg("name", statement.variable->mangled_name()),
		fmt::arg("tag", statement.saved_tag));
}

void CodeGen::statement_for_finalize(ForStatement statement)
{
	m_output << fmt::format(
		"\taddq $1, {name}\n"
		"\tjmp __for{tag}\n"
		"__next{tag}:\n",
		fmt::arg("name", statement.variable->mangled_name()),
		fmt::arg("tag", statement.saved_tag));
}

void CodeGen::debug_display(Type type)
{
	switch (type)
	{
	case Type::UNSIGNED_INT:
	{
		m_output << "\tmovq $__cc_format_string_llu, %rdi\n"
					"\tpop %rsi\n"
					"\tmovb $0, %al # number of float parameters (varargs)\n";
		break;
	}

	case Type::BOOLEAN:
	{
		m_output << "\tmovq $__cc_format_string_llu, %rdi\n"
					"\tpop %rsi\n"
					"\tandq $0x1, %rsi # restrict bool output to 0 or 1\n"
					"\tmovb $0, %al # number of float parameters (varargs)\n";
		break;
	}

	case Type::CHAR:
	{
		m_output << "\tmovq $__cc_format_string_c, %rdi\n"
					"\tpop %rsi\n"
					"\tmovb $0, %al # number of float parameters (varargs)\n";
		break;
	}

	case Type::DOUBLE:
	{
		m_output << "\tmovq $__cc_format_string_f, %rdi # Write 1st parameter\n"
					"\tmovsd (%rsp), %xmm0 # Write 2nd parameter - load 64-bit double from stack to xmm0, clear "
					"upper bits\n"
					"\taddq $8, %rsp # Effectively pop the double from the stack.\n"
					"\tmovb $1, %al # number of float parameters (varargs)\n";
		break;
	}

	default:
	{
		throw UnimplementedTypeSupportError{};
	}
	}

	m_output << "\taddq $-8, %rsp # Align stack to 16-byte. There is a 8-byte value on the stack already, that is, the "
				"ret pointer. FIXME: this is probably not going to work well if things are pushed on the stack "
				"already, e.g. procedure parameters that do not fit in registers.\n"
				"\tcall printf\n"
				"\taddq $8, %rsp # Cancel the alignement done earlier\n";
}

void CodeGen::alu_load_binop(Type type)
{
	switch (type)
	{
	case Type::UNSIGNED_INT:
	case Type::BOOLEAN:
	{
		m_output << "\tpop %rbx\n"
					"\tpop %rax\n";

		break;
	}

	case Type::DOUBLE:
	{
		m_output << "\tfldl (%rsp)\n"
					"\tfldl 8(%rsp)\n"
					"\taddq $16, %rsp\n";
		break;
	}

	default:
	{
		throw UnimplementedTypeSupportError{};
	}
	}
}

void CodeGen::alu_store_f64()
{
	m_output << "\taddq $-8, %rsp\n"
				"\tfstpl (%rsp)\n";
}

void CodeGen::alu_compare(Type type, string_view instruction)
{
	alu_load_binop(type);

	switch (type)
	{
	case Type::UNSIGNED_INT:
	{
		m_output << "\tcmpq %rbx, %rax\n";
		break;
	}

	case Type::DOUBLE:
	{
		m_output << "\tfcomip\n"
					"\tfstp %st(0) # Clear fp stack\n";
		break;
	}

	default:
	{
		throw UnimplementedTypeSupportError{};
	}
	}

	++m_label_tag;

	m_output << fmt::format(
		"\t{jumpinstruction} __true{tag}\n"
		"\tpush $0x0 # No branching: push false\n"
		"\tjmp __next{tag}\n"
		"__true{tag}:\n"
		"\tpush $0xFFFFFFFFFFFFFFFF\n"
		"__next{tag}:\n",
		fmt::arg("jumpinstruction", instruction.str()),
		fmt::arg("tag", m_label_tag));
}
