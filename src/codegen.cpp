#include "codegen.hpp"

#include "compiler.hpp"
#include "types.hpp"

#include <ostream>

void CodeGen::begin_program() { m_output << "# This code was generated by ceri-compiler\n"; }
void CodeGen::finalize_program() {}

void CodeGen::begin_executable_section() { m_output << ".text\n"; }
void CodeGen::finalize_executable_section() {}

void CodeGen::begin_main_procedure()
{
	m_output << ".globl main\n"
				"main:\n"
				"\tmovq %rsp, %rbp # Save the position of the top of the stack\n";
}

void CodeGen::finalize_main_procedure()
{
	m_output << "\t movq %rbp, %rsp # Restore the position of the top of the stack\n"
				"\tret\n";
}

void CodeGen::begin_global_data_section()
{
	m_output << ".data\n"
				".align 8\n"
				"__cc_format_string_llu: .string \"%llu\\n\"\n";
}

void CodeGen::finalize_global_data_section() {}

void CodeGen::define_global_variable(const Variable& variable)
{
	m_output << variable.name << ":\t.quad 0 # type: " << type_name(variable.type.type) << '\n';
}

void CodeGen::load_variable(const Variable& variable) { m_output << "\tpush " << variable.name << '\n'; }
void CodeGen::load_i64(int64_t value) { m_output << "\tpush $" << value << '\n'; }

void CodeGen::store_variable(const Variable& variable) { m_output << "\tpop " << variable.name << '\n'; }

void CodeGen::alu_and_bool()
{
	alu_load_binop_i64();

	m_output << "\tandq %rax, %rbx\n"
				"\tpush %rax\n";
}

void CodeGen::alu_or_bool()
{
	alu_load_binop_i64();

	m_output << "\torq %rbx, %rax\n"
				"\tpush %rax\n";
}

void CodeGen::alu_add_i64()
{
	alu_load_binop_i64();

	m_output << "\taddq %rbx, %rax\n"
				"\tpush %rax\n";
}

void CodeGen::alu_sub_i64()
{
	alu_load_binop_i64();

	m_output << "\tsubq %rbx, %rax\n"
				"\tpush %rax\n";
}

void CodeGen::alu_multiply_i64()
{
	alu_load_binop_i64();

	m_output << "\tmulq %rbx\n"
				"\tpush %rax\n";
}

void CodeGen::alu_divide_i64()
{
	alu_load_binop_i64();

	m_output << "\tmovq $0, %rdx # Higher part of numerator\n"
				"\tdiv %rbx # Quotient goes to %rax\n"
				"\tpush %rax\n";
}

void CodeGen::alu_modulus_i64()
{
	alu_load_binop_i64();

	m_output << "\tmovq $0, %rdx # Higher part of numerator\n"
				"\tdiv %rbx # Remainder goes to %rdx\n"
				"\tpush %rax\n";
}

void CodeGen::alu_equal_i64() { alu_compare_i64("je"); }
void CodeGen::alu_not_equal_i64() { alu_compare_i64("jne"); }
void CodeGen::alu_greater_equal_i64() { alu_compare_i64("jae"); }
void CodeGen::alu_lower_equal_i64() { alu_compare_i64("jbe"); }
void CodeGen::alu_greater_i64() { alu_compare_i64("ja"); }
void CodeGen::alu_lower_i64() { alu_compare_i64("je"); }

void CodeGen::alu_load_binop_i64()
{
	m_output << "\tpop %rbx\n"
				"\tpop %rax\n";
}

void CodeGen::alu_compare_i64(string_view instruction)
{
	alu_load_binop_i64();

	++m_label_tag;

	// Multiple separate calls here because formatting wrecks the whole thing into an unreadable mess somehow

	m_output << "\tcmpq %rbx, %rax\n";

	m_output << "\t" << instruction << " __true" << m_label_tag << "\n";

	m_output << "\tpush $0x0 # No branching: push false\n"
				"\tjmp __next"
			 << m_label_tag << '\n';

	m_output << "__true" << m_label_tag
			 << ":\n"
				"\tpush $0xFFFFFFFFFFFFFFFF\n";

	m_output << "__next" << m_label_tag << ":\n";
}
